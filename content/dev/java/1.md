---
title: "[Java] 기타제어자"
author: 신용준
---

## final 제어자

자바에서 final 제어자는 '변경할 수 없다'는 의미로 사용됩니다.

즉, 필드나 지역 변수에 사용하면 값을 변경할 수 없는 상수(constant)가 됩니다.
또한, 클래스에 사용하면 해당 클래스는 다른 클래스가 상속받을 수 없게 됩니다.
메소드에 사용하면 해당 메소드는 오버라이딩(overriding)을 통해 재정의를 할 수 없게 됩니다.

<br>

>자바에서는 상속이라는 것을 통해 다른 클래스의 private 멤버를 제외한 모든 메소드를 상속받을 수 있습니다.
이렇게 상속받은 메소드는 그대로 사용해도 되고, 필요한 동작을 위해 재정의하여 사용할 수도 있습니다.
메소드 오버라이딩(method overriding)이란 상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것을 의미합니다.

<br>

자바에서 final 제어자를 사용할 수 있는 대상은 다음과 같습니다.
- 클래스, 메소드, 필드, 지역 변수

<br>

```java
final class Car {
    final int VAR;
    final void brake() {
        final double MAX_NUM = 10.2;
    }
}
```

<br>

## static 제어자

자바에서 static 제어자는 '공통적인'이라는 의미로 사용됩니다.

즉, static 제어자를 변수에 사용하면 해당 변수를 클래스 변수로 만들어 줍니다.
또한, 메소드에 사용하면 해당 메소드를 클래스 메소드로 만들어 줍니다.
이러한 static 제어자는 초기화 블록에도 사용할 수 있습니다.

<br>

static 제어자를 가지는 멤버는 다음과 같은 특징을 가지게 됩니다.

1. 프로그램 시작시 최초에 단 한 번만 생성되고 초기화됩니다.
2. 인스턴스를 생성하지 않고도 바로 사용할 수 있게 됩니다.
3. 해당 클래스의 모든 인스턴스가 공유합니다.

<br>

자바에서 static 제어자를 사용할 수 있는 대상은 다음과 같습니다.

- 메소드, 필드, 초기화 블록

<br>

```java
class Car {
    static int var; // 클래스 필드(static 변수)
    static { // static 초기화 블록
        // 보통 클래스 필드의 초기화를 진행함
    }
    static void brake() { // 클래스 메소드(static 메소드)
        ...
    }
}
```

<br>

## abstract 제어자

자바에서 abstract 제어자는 '추상적인'이라는 의미로 사용됩니다.

선언부만 있고 구현부가 없는 메소드를 추상 메소드라 하며, 반드시 abstract 제어자를 붙여야 합니다.
또한, 하나 이상의 추상 메소드가 포함하고 있는 추상 클래스도 반드시 abstract 제어자를 붙여야 합니다.

<br>

자바에서 abstract 제어자를 사용할 수 있는 대상은 다음과 같습니다.
- 클래스, 메소드

<br>

```java
abstract class Car { // 추상 클래스
    abstract void brake(); // 추상 메소드
}
```

<br>

## 제어자의 조합

자바에서는 접근 제어자와 기타 제어자를 한 대상에 함께 사용할 수 있습니다.
하지만 모든 경우가 가능한 것은 아니며, 대상에 따라 사용할 수 있는 조합은 다음과 같습니다.

<br>

| 대상 | 함께 사용할 수 있는 제어자 |
|:-|:-|
| 클래스 | public, (default), final, abstract |
| 메소드 | 모든 접근 제어자, final, static, abstract|
| 필드 | 모든 접근 제어자, final, static |
| 지역 변수 | final |
| 초기화 블록 | static |

<br>

또한, 자바에서는 제어자의 특성상 몇몇 제어자는 함께 사용할 수 없습니다.

1. 클래스에 final과 abstract는 함께 사용할 수 없습니다.
final 제어자를 가지는 클래스는 다른 클래스가 상속받을 수 없게 되며, abstract 제어자를 가지는 클래스는 다른 클래스가 상속해서 오버라이딩해야만 사용할 수 있으므로, 이 두 제어자는 클래스에 함께 사용할 수 없습니다.
2. 메소드에 static과 abstract는 함께 사용할 수 없습니다.
abstract 제어자를 가지는 메소드는 선언부만 있고 구현부가 없는 메소드인데, static 제어자를 가지는 메소드는 인스턴스를 생성하지 않고도 바로 사용할 수 있어야 하므로, 이 두 제어자는 메소드에 함께 사용할 수 없습니다.
3. 메소드에 private과 abstract는 함께 사용할 수 없습니다.
abstract 제어자를 가지는 메소드는 다른 클래스가 상속하여 오버라이딩해야만 사용할 수 있는데, private 제어자를 가지는 메소드는 자식 클래스에서 접근할 수 없게 되므로, 이 두 제어자는 메소드에 함께 사용할 수 없습니다.
4. 메소드에 private과 final은 함께 사용할 필요가 없습니다.
메소드에 사용된 final 제어자와 private 제어자는 모두 해당 메소드가 오버라이딩을 통한 재정의를 할 수 없다는 의미를 가지므로, 둘 중에 하나만 사용해도 의미가 충분히 전달될 수 있습니다.

<br>

출처 : <http://www.tcpschool.com/java/java_modifier_ectModifier>{:target="_blank"}